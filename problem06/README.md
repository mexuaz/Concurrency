# Problem 06

This problem is implementing a semi-parallel sort, the procedure is as follow:
1. Break the list of integers in to n portion
2. Sort each portion in a different thread
3. When all the sorts are done merge them to one list

Some parts could be done more in parallel like when at least two threads finished sorting start merging them but in order to keep the source a little more comprehensible I skip that approach.

## performance Evaluation

performance for both C++ and Go are measured by timing in milli seconds units for a list of 100,000,000 integers.
C++ performance measure in different level of optimization. Since there were no optimization configuration for Go standard compiler the results for Go are just generated by executing build binary file.



| splits  |  C++ O  |  C++ O1 |  C++ O2  |  C++ O3  |   Go  |
|:-------:|:-----:|:-----:|:-----:|:-----:|:-----:|
| 1       | 11616 | 11606 | 11423 | 11819 | 40006 |
| 2       | 7749  | 7883  | 7510  | 7741  | 26081 |
| 4       | 6441  | 6460  | 6117  | 6252  | 19637 |
| 8       | 5826  | 5810  | 5364  | 5388  | 16727 |
| 16      | 6719  | 6757  | 6173  | 6157  | 18036 |
| 32      | 7634  | 7686  | 7019  | 6986  | 18990 |
| 64      | 8429  | 8427  | 7622  | 7592  | 20407 |


## Observations:

* Best time for both languages was for 8 splits which I think happened because of my CPU core numbers in notebook is 8. 

* Increasing number of threads affected C++ program more than Go, this could be happened because Go threads are lighter than C++.

* The interesting fact is that C++ sequential version (1 split) is faster than Go's best result for 8 split!

* Optimization doesn't contribute much to C++ except in case of increased thread numbers.


If you look at the source code the Go implementation is similar to C++ one this means C++ was faster for this problem.













